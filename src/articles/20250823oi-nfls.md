## S+CSP2025模拟赛8

### A. 输出字符串

纯模拟题，题意懒得打了。。。

```cpp
#include <bits/stdc++.h>
#define int int64_t

int P[26];
std::vector<std::string> V[26];

signed main() {
    freopen("zigzag.in", "r", stdin);
    freopen("zigzag.out", "w", stdout);

    int n, q;
    std::string S;

    std::cin >> n >> q;

    for (int i = 1; i <= n; i++) {
        std::cin >> S;
        V[S[0] - 'a'].push_back(S);
    }

    for (int i = 0; i < 26; i++) std::sort(V[i].begin(), V[i].end());

    for (int i = 1; i <= q; i++) {
        char ch;
        std::cin >> ch;

        std::cout << V[ch - 'a'][P[ch - 'a']] << "\n";
        P[ch - 'a'] += 1;
        P[ch - 'a'] %= V[ch - 'a'].size();
    }

    return 0;
}
```

### B. 最优排列翻转

给定一排列 $\{p_1,\dots,p_n\}$，对于全部 $1\leqslant l\leqslant r\leqslant n$，求将 $[p_l,\dots,p_r]$ 翻转后最多能有多少个 $p_i$ 满足 $i$？

做法：显然这个东西需要枚举一维，枚举 $l$ 还是枚举 $r$ 都非常不可做。于是考虑逆向思维。反转的区间要满足什么条件才能让 $p_i$ 变到正确的位置上？答案只和区间是否覆盖 $p_i$ 和区间的中点有关。因此我们只需要枚举中点，显然此时确定中点情况下左右端点必有一个是 $p_i$，因为如果多出来一点一定不会让答案增加。贪心即可。$\mathcal{O}(n)$。

```cpp
#include <bits/stdc++.h>
#define int int64_t

const int N = 524288;

int n, A[N], P[N];
int Prefix[N];
std::vector<int> Posit[N];
std::vector<int> Space[N];

int Sum(int l, int r) {
    if (l > r)
        return 0;
    if (l < 1)
        return Prefix[r];
    if (r < 1)
        return 0;
    if (r > n)
        r = n;
    if (l > n)
        return 0;
    int x = Prefix[r];
    return x - Prefix[l - 1];
}

int Abs(int x) {
    if (x < 0)
        return -x;
    return x;
}

signed main() {
    freopen("reverse.in", "r", stdin);
    freopen("reverse.out", "w", stdout);

    std::cin.tie(nullptr);
    std::cin.sync_with_stdio(false);

    std::cin >> n;
    for (int i = 1; i <= n; i++) {
        std::cin >> A[i];
        P[A[i]] = i;
    }

    for (int i = 1; i <= n; i++) Prefix[i] = Prefix[i - 1] + (A[i] == i);

    for (int i = 1; i <= n; i++) {
        int t = Abs(i - P[i]);
        if (t & 1) {
            int x = std::min(i, P[i]) + t / 2;
            Space[x].push_back(i);
        } else {
            int x = std::min(i, P[i]) + t / 2;
            Posit[x].push_back(i);
        }
    }

    for (int i = 1; i <= n; i++) {
        std::sort(Posit[i].begin(), Posit[i].end(), [&](int a, int b) {
            int distA = Abs(a - i);
            int distB = Abs(b - i);
            return distA < distB;
        });
        std::sort(Space[i].begin(), Space[i].end(), [&](int a, int b) {
            a = std::min(a, P[a]);
            b = std::min(b, P[b]);
            int distA = Abs(a - i);
            int distB = Abs(b - i);
            return distA < distB;
        });
    }

    int ans = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < Posit[i].size(); j++) {
            int endval = Posit[i][j];
            int l = std::min(endval, P[endval]);
            int r = std::max(endval, P[endval]);
            ans = std::max(ans, Sum(1, l - 1) + Sum(r + 1, n) + j + 1);
        }
        for (int j = 0; j < Space[i].size(); j++) {
            int endval = Space[i][j];
            int l = std::min(endval, P[endval]);
            int r = std::max(endval, P[endval]);
            ans = std::max(ans, Sum(1, l - 1) + Sum(r + 1, n) + j + 1);
        }
    }

    std::cout << ans - Prefix[n] << "\n";

    return 0;
}
```

### C. 比赛

给定一棵以 $1$ 为根的树，有 $m$ 个跳板，每个跳板可以在 $p_i$ 花费 $v_i$ 的代价向上跳 $1\sim w_i$ 次。现有 $q$ 次询问，问在上述规则下 $x$ 到 $1$ 的最少花费？数据保证有解。

解法：有一个显然的 $\text{DP}$：

$\text{dp}_i = \min(\min(\text{ancestors}(i,w_j))+v_i)(p_j=i,w_j,v_j)$。

翻译一下：$\text{dp}_i$ 的决策点是 $i$ 的 $1 \sim w_j$ 级祖先。

显然，树链剖分优化即可。

```cpp
#include <bits/stdc++.h>
#define int int64_t

const int L = 32;
const int N = 262144;
const int INF = (1ll << 55);

int n, m, q;
std::vector<signed> G[N];
std::vector<std::pair<signed, int>> Maps[N];

int Siz[N], Dep[N], Par[N], Heavy[N];
int Dfn[N], Lis[N], Chain[N], cntDfn;
signed ST[L][N];
int Ans[N];

struct Segmentree {
    int l, r, mid;
    int minval;
    Segmentree *ls, *rs;

    Segmentree(int ll, int rr) {
        l = ll, r = rr;
        mid = (l + r) / 2;
        minval = INF;

        if (l != r) {
            ls = new Segmentree(l, mid);
            rs = new Segmentree(mid + 1, r);
        }
    }

    void Modify(int pos, int cnt) {
        if (l == r) {
            minval = cnt;
        } else {
            if (pos <= mid)
                ls->Modify(pos, cnt);
            else
                rs->Modify(pos, cnt);
            minval = std::min(ls->minval, rs->minval);
        }
    }

    int Query(int ll, int rr) {
        if (ll <= l && r <= rr) {
            return minval;
        } else {
            if (ll <= mid && mid < rr)
                return std::min(ls->Query(ll, rr), rs->Query(ll, rr));

            if (ll <= mid)
                return ls->Query(ll, rr);

            return rs->Query(ll, rr);
        }
    }
} * DP;

void DFSBuild(int u, int from, int dep) {
    Par[u] = from;
    Dep[u] = dep;
    Siz[u] = 1;

    for (auto v : G[u])
        if (v != from) {
            DFSBuild(v, u, dep + 1);
            Siz[u] += Siz[v];

            if (Siz[v] > Siz[Heavy[u]])
                Heavy[u] = v;
        }
}

void DFSChain(int u, int top) {
    Chain[u] = top;
    Dfn[u] = ++cntDfn;
    Lis[cntDfn] = u;

    if (Heavy[u]) {
        DFSChain(Heavy[u], top);

        for (auto v : G[u])
            if (v != Par[u] && v != Heavy[u])
                DFSChain(v, v);
    }
}

int Ancestor(int u, int layer) {
    for (int i = 0; i <= 25; i++)
        if (layer >> i & 1)
            u = ST[i][u];
    return u;
}

void TreeDP(int u) {
    if (u != 1) {
        Ans[u] = INF;
        for (auto e : Maps[u]) {
            int cost = e.second;
            int layer = std::min((int)(e.first), Dep[u]);

            int v = Ancestor(u, layer);
            int copyu = u;

            while (Chain[copyu] != Chain[v])
                Ans[u] = std::min(Ans[u], DP->Query(Dfn[Chain[copyu]], Dfn[copyu]) + cost),
                copyu = Par[Chain[copyu]];

            Ans[u] = std::min(Ans[u], DP->Query(Dfn[v], Dfn[copyu]) + cost);
        }

        DP->Modify(Dfn[u], Ans[u]);
    }

    for (auto v : G[u]) {
        if (v != Par[u])
            TreeDP(v);
    }
}

signed main() {
    freopen("match.in", "r", stdin);
    freopen("match.out", "w", stdout);

    std::cin.tie(nullptr);
    std::cin.sync_with_stdio(false);

    std::cin >> n >> m >> q;

    int u, v, w;
    for (int i = 1; i < n; i++) {
        std::cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }

    for (int i = 1; i <= m; i++) {
        std::cin >> u >> v >> w;
        Maps[u].emplace_back(v, w);
    }

    DFSBuild(1, 0, 0);
    DFSChain(1, 1);

    for (int i = 1; i <= n; i++) ST[0][i] = Par[i];

    for (int i = 1; 1 << i <= n; i++)
        for (int j = 1; j <= n; j++) ST[i][j] = ST[i - 1][ST[i - 1][j]];

    DP = new Segmentree(1, n);
    DP->Modify(Dfn[1], 0);
    Ans[1] = 0;

    TreeDP(1);

    while (q--) {
        std::cin >> u;
        std::cout << Ans[u] << "\n";
    }

    return 0;
}
```

### D. 圣杯战争